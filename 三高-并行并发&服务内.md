# 三高项目-服务内并发

cap：分布式系统的起点。

一致性，可用性，分区容错性。

P：分区容错性。分区，容错。

因为有网络的8大谬误：

网络是可靠的。

没有延迟

带宽无限

网络安全

拓扑结构不变

只有一个管理员

传输代价没有，为0

网络是同构的

怎么解决分区容错。

单体应用。

条理：

C：从读和写，一致性。

一致：

不一致：

一致性分哪几类：

强一致性：

弱一致性：能容忍部分或全部 看不到最新的数据。

最终一致性：经过一段时间，能看到最新的数据。

A：可用性。

可用：

不可用：

AC是冲突的。

---

cap，一般不用业务做说明。

互联网中大部分场景下：A&#x3e;C。

cap：

舍弃P：单点数据库。（但是 考虑 数据库集群的时候，就要考虑P。）

舍弃A：zk

舍弃C：多了。eureka。

---

AP，舍弃C。舍弃强一致性，保证最终一致性。大厂。通过最终一致性 兼顾了 三个特性。

读多写少。

---

# 内部并发

进程

线程

协程

分配资源，开销，资源，环境，耗时。

docker，不同端口启动（主要是利用资源的隔离性）。

线程：

网约车中：计价，按时长收费+路程收费=总费用。

多线程目的2个：

提升效率：io读数据，cpu去计算，io输出。

实现异步：主线程提前释放，后面还需要一个耗时很长的任务。降低了平均响应时间，并发就上来了。主线程执行重要的任务，不重要的考后。发邮件，记日志。与第三方的交互（国家信息的上报）。

线程数的计算：

公式1：线程数=cpu核数 *  cpu使用率  * （1+ w/c）。

时间段：1s 0。8s在干活    80%。  0.3/ 2 = 15%。

实际经验：70%，开始预警。

平均负载：top  1min,5min,15min  loadaverege

0.7 * cpu核数  2   ,1.4

平均负载  大于 0.7* 核数，要开始排查原因，防止系统恶化。

1.0 * 核数  ，解决。

大于 5 * cpu核数，问题已经很严重了。

1min,5min,15min  loadaverege

w/c:等待时间/计算时间。

2 50% 2ms，1ms =      3 ,       2 * 0。5 * （1+2/1）=3

公式2：线程数 =  cpu核数 * （1-阻塞系数）

计算密集型：0，IO：1。中间？

---

cpu核数 * （1+ w/c） = cpu核数 /（1-阻塞系数）

阻塞系数 = w/w+c。

---

其实不重要：

实际中  先定一个数，然后再压测。以 **压测 **为准。谁能看代码 ，算出线程数。他牛B。

2 * cpu核数。

---

预估用户量，预估并发量，看cpu，看内存，看网络，看io，能不能扛的住。

---

没必要：

协程 ：线程中的线程。java官方并没有推出。一个方法被阻塞，它执行另一个方法。

Quasar。jar包。

压栈 出栈。SuspendExecution  。

进程&#x3e;线程&#x3e;协程。

---
